#include "../inc/production.h"

std::unordered_map<string, Symbol> terminals = {
	{"zakres", ZAKRES},
	{"dycha", DYCHA},
	{"przecinek", PRZECINEK},
	{"tekst", TEKST},
	{"nic", NIC},
	{"funkcja", FUNKCJA},
	{"id", IDENTIFIER},
	{"const", CONSTANT},
	{"(", OPENING_ROUND},
	{")", CLOSING_ROUND},
	{",", COMA},
	{":", COLON},
	{";", SEMICOLON},
	{"{", OPENING_CURLY},
	{"}", CLOSING_CURLY},
	{"przestan", PRZESTAN},
	{"dalej", DALEJ},
	{"zwroc", ZWROC},
	{"wywolaj", WYWOLAJ},
	{"dopoki", DOPOKI},
	{"dla", DLA},
	{"jesli", JESLI},
	{"=", ASSIGN},
	{"inaczej", INACZEJ},
	{"==", DOUBLE_EQUAL},
	{"!=", NOT_EQUAL},
	{">", MORE},
	{"<", LESS},
	{">=", MORE_EQUAL},
	{"<=", LESS_EQUAL},
	{"&", AND_OP},
	{"|", OR_OP},
	{"+", PLUS},
	{"- ", MINUS},
	{"*", MULTIPLY},
	{"/", DIVIDE}

};

Symbol translateTokenToSymbol(const Token& token)
{
	switch(token.type)
	{
		case TYPE::Id:
			return IDENTIFIER;
			break;
		case TYPE::Str:
			return CONSTANT;
			break;
		case TYPE::Int:
			return CONSTANT;
			break;
		case TYPE::Float:
			return CONSTANT;
			break;
		default:
			return terminals[token.value];
			break;
	}
	return ERROR;
}

vector<Production> grammar = {	
	{VARDECL, {DATATYPE, IDENTIFIER}},
	{DATATYPE, {DYCHA}},
	{DATATYPE, {PRZECINEK}},
	{DATATYPE, {TEKST}},
	{DATATYPE, {NIC}},
	{FUNCTIONDECLARATION, {FUNKCJA, IDENTIFIER, PARAMLIST, FUNCTYPE, BODY}},
	{PARAMLIST, {OPENING_ROUND, PARAMDECLS, CLOSING_ROUND}},
	{PARAMDECLS, {VARDECL, PARAMDECLSNEW}},
	{PARAMDECLS, {EPSILON}},
	{PARAMDECLSNEW, {COMA, VARDECL, PARAMDECLSNEW}},
	{PARAMDECLSNEW, {EPSILON}},
	{FUNCTYPE, {COLON, DATATYPE, COLON}},
	{BODY, {OPENING_CURLY, STATEMENTS, CLOSING_CURLY}},
	{STATEMENTS, {STATEMENT, STATEMENTS}},
	{STATEMENTS, {EPSILON}},
	{STATEMENT, {PRZESTAN, SEMICOLON}},
	{STATEMENT, {DALEJ, SEMICOLON}},
	{STATEMENT, {ZWROC, FACTOR, SEMICOLON}},
	{STATEMENT, {VARDECL, VARINIT, SEMICOLON}},
	{STATEMENT, {IDENTIFIER, VARINIT, SEMICOLON}},
	{STATEMENT, {EPSILON}},
	{STATEMENT, {WYWOLAJ, IDENTIFIER, ARGLIST}},
	{STATEMENT, {DOPOKI, CONDITION, COLON, BODY}},
	{STATEMENT, {DLA, IDENTIFIER, ZAKRES, OPENING_ROUND, FORRANGE, CLOSING_ROUND, COLON, BODY}},
	{STATEMENT, {JESLI, CONDITION, COLON, BODY, ELSECLAUSE}},
	{VARINIT, {ASSIGN, EXPRESSION}},
	{VARINIT, {EPSILON}},
	{FORRANGE, {EXPRESSION, FORRANGENEW}},
	{FORRANGENEW, {COMA, EXPRESSION}},
	{FORRANGENEW, {EPSILON}},
	{ARGLIST, {OPENING_ROUND, FUNCARGS, CLOSING_ROUND}},
	{FUNCARGS, {EXPRESSION, FUNCARGSNEW}},
	{FUNCARGS, {EPSILON}},
	{FUNCARGSNEW, {COMA, EXPRESSION, FUNCARGSNEW}},
	{FUNCARGSNEW, {EPSILON}},
	{ELSECLAUSE, {INACZEJ, ELSE}},
	{ELSECLAUSE, {EPSILON}},
	{ELSE, {JESLI, CONDITION, COLON, BODY, ELSECLAUSE}},
	{ELSE, {BODY}},
	{CONDITION, {EXPRESSION, CONDITIONNEW}},
	{CONDITIONNEW, {LOGOP, EXPRESSION, CONDITIONNEW}},
	{CONDITIONNEW, {EPSILON}},
	{LOGOP, {DOUBLE_EQUAL}},
	{LOGOP, {NOT_EQUAL}},
	{LOGOP, {MORE}},
	{LOGOP, {LESS}},
	{LOGOP, {MORE_EQUAL}},
	{LOGOP, {LESS_EQUAL}},
	{LOGOP, {AND_OP}},
	{LOGOP, {OR_OP}},
	{ADDOP, {PLUS}},
	{ADDOP, {MINUS}},
	{MULOP, {MULTIPLY}},
	{MULOP, {DIVIDE}},
	{EXPRESSION, {TERM, EXPRESSIONNEW}},
	{EXPRESSIONNEW, {ADDOP, TERM, EXPRESSIONNEW}},
	{EXPRESSIONNEW, {EPSILON}},
	{TERM, {FACTOR, TERMNEW}},
	{TERMNEW, {MULOP, FACTOR, TERMNEW}},
	{TERMNEW, {EPSILON}},
	{FACTOR, {IDENTIFIER}},
	{FACTOR, {CONSTANT}},
	{FACTOR, {OPENING_ROUND, EXPRESSION, CLOSING_ROUND}},
	{FACTOR, {WYWOLAJ, IDENTIFIER, ARGLIST}}
};

